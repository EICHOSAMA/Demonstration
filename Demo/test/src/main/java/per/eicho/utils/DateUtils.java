package per.eicho.utils;

public final class DateUtils {
    /**
     * <p>判断给定年份是否为闰年</p>
     * <pre>
     *  判断是否为闰年的算法为：
     *   1. 必须是4的倍数。
     *   2. 100的倍数时必须是400的倍数。
     * </pre>
     * 
     * <p>知其所以然之：闰年的由来</p>
     * <pre>
     *  闰年的由来是因为我们认为规定1天是24小时（= 86,400s），1年是365天。
     *  而实际上地球绕太阳一圈（公转）时间为365天5小时48分6秒，也就是一自然年。
     *  自然年也被称为太阳年、回归年，英：natural year
     *  但实际上地球：
     *    - 规定一年需要的时间是：365d  0h  0m  0s
     *    - 公转一圈需要的时间是：365d  5h 48m 46s
     *  
     *  可以计算知道：
     *     - 每过去一年时间，我们就超前地球实际位置  5h 48m 46s。
     *     - 每过去四年时间，我们就超前地球实际位置 23h 15m  4s ≈ 1d
     *  就好比四年过后，地球实际位置在 3圈359度的地方，而我们认为其应该在4圈整的地方。
     *  这种误差放大之后会导致节气有差距。就比方说不调整的话，接近800年时间我们的夏冬就会对调一次。
     *  因此有了闰年（leap year）的出现。
     * 
     *  每四年人为添加一个闰日（leap day）用于等待地球实际位置慢慢公转至我们认为其应该在的位置。
     *  因为我们每四年会等待24小时，那么引入这种制度后：
     *     - 每过去四年时间，我们就落后地球实际位置  0h 44m 56s
     *     - 每过去百年时间，我们就落后地球实际位置 18h 43m 20s 不足一日
     *     - 每过去四百年时，我们就落后地球实际位置 74h 53m 20s ≈ 3d
     *  为此我们还需要除去3天润日，缩小我们落后地球实际位置的差距：这种制度为每400年的后3个100年不算做闰年。
     *  
     *  细心的你一定也发现其实就算剥离3个闰日后：
     *     - 每过去四百年时，我们还是落后地球的位置  2h 53m 20s ≈ 3h
     *  那么八个四百年也就是3200年后，我们有会落后地球位置 约1天...不过这个时间跨度太长
     *  而计算机或是人类发展史又太短，目前还没纳入到我们日常使用的算法之中。
     * </pre>
     * 
     * @param year 待判定的年份，负数为公元前，正数为公元后。
     * @return boolean型，true代表给定年份是闰年。
     */
    public static boolean isLeapYear(int year) {
        return year % 4 == 0 // 1. 最大程度筛出平年（-75%）直接返回false，剩余25%数据中平年仅占3%。
            && (year % 100 != 0 // 2. 最大程度筛出闰年（-96%）直接返回true，剩余4%数据中闰年占25%。
                || year % 400 == 0); // 3. 最后一步从剩余的数据中选出剩余25%的闰年返回true。
    }

    private DateUtils() {}
}
